---
description: You are a TypeScript/React expert with deep knowledge of modular monolith architecture, DRY/SOLID/CQRS patterns, and strict typing. Your task is to update the new implementation so it operates identically to the legacy (verbose) version. Use a direct
---



New Implementation: [Insert path or code snippet of the new file/component]
Legacy Implementation: [Insert path or code snippet of the legacy/verbose file/component]
Instructions
Component & Subcomponent Comparison
Identify all components, subcomponents, hooks, and utilities used in both files.
For each component/subcomponent present in the legacy file but missing or altered in the new file, restore or adjust its logic and usage in the new file to match the legacy behavior.
Prop, State, and Method Parity
Compare all props, state variables, methods, and events.
Add back or modify any missing/changed props, state, or methods in the new file to ensure full behavioral parity with the legacy version.
Logic & Flow Restoration
Analyze all conditional logic, rendering flows, and side effects in the legacy file.
Update the new file and subfiles to exactly match these flows, unless an explicit optimization or modernization is required by the project’s standards.
Edge Cases & Error Handling
Ensure all edge cases, error handling, and user flows present in the legacy file are also present in the new file.
Code Quality
Apply best practices for your stack (strict typing, modularization, Zod validation, etc.) while restoring legacy behavior.
Add meaningful comments using the project’s better-comments tags.
Output Format
Directly update the new file’s code.
For each change, add a brief inline comment explaining the adjustment and referencing the legacy file section.